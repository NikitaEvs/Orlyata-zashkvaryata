Документация к серверу

1) Авторизация
Как таковой, авторизации теперь нет, но есть возможность проверить валидность пары логин/пароль
При открытии соединения сервер предлагает эту возможность (её можно проигнорировать) и отсылает 
JSON в формате: 
{
	"event": "authNotify",
	"data": "info": "null"
}
Для проверки необходимо отправить запрос в форме JSON:
{
	"event": "authReq",
	"data": "login": "логин для проверки",
			"pass": "пароль для проверки"
}
В ответ сервер пришлёт ответ в форме:
Если пара логин-пароль существует
{
	"event": "authResp",
	"data": "ok"
}
Если же нет
{
	"event": "authResp",
	"data": "fail"
}
2) Регистрация
Необходимо прислать имя коробки для регистрации, а также уникальный логин и пароль в формате:
{
	"event": "regReq",
	"data": "name": "имя коробки для регистрации",
			"login": "логин",
			"pass": "пароль"
}
На это сервер даст ответ в формате:
Если регистрация прошла успешно
{
	"event": "regResp",
	"data": "ok"
}
Если же нет
{
	"event": "regResp",
	"data": "fail"
}
3) Получение данных
Теперь получение данных имеет форму запрос-ответ, для каждого запроса также должна быть указана пара логин-пароль
Форма запроса:
{
	"event": "dataReq",
	"auth": "login": "логин",
			"pass": "пароль",
	"type": "тип запрашиваемых данных"
}
Возможные type:
"now" - последнее полученное значение
"hour" - все данные за последний час 
"day" - все данные за последний день
"month" - все данные за последнюю неделю

На это сервер даст ответ:
Если пара логин-пароль валидна:
{
	"event": "dataResp",
	"type": "запрашиваемый тип",
	"data": JSON файл с запрашиваемыми данными
}
Если же нет
{
	"event": "dataResp",
	"type": "fail",
	"data": "null"
}
Формат JSON файлов с данными
Для type == now:
{
	"time": "timestamp в формате %d.%m.%Y %H:%M:%S",
	"types": массив значений типов приборов, соответствующий текущемы значению от машинного алгоритма, парсится на сервере с помощью config-файла dataset.json,
	"value": суммарная нагрузка приборов,
	"values": массив значений потребления соответствующих приборов (в мА)
}
Для type == hour:
{
	"time": "timestamp в формате %d.%m.%Y %H",
	"powerScore": суммарное потребление со всех измерений за текущий час,
	"countMeasures": количество измерений за текущий час,
	"power": среднее значение потребления за текущий час (если час ещё не закончился, то данное значение равно 0, его можно отдельно посчитать, поделив powerScore на countMeasures),
	"types": массив значений типов приборов, соответствующий текущемы значению от машинного алгоритма, парсится на сервере с помощью config-файла dataset.json,
	"values": массив значений потребления соответствующих приборов (в мА), при чём нагрузка будет суммарная за весь текущий час
}
Для type == day:
{
	"countMeasures": количество измерений,
	"hours": массив данных по часам в формате для type == hour,
	"power": среднее значение потребления за текущий день (если день ещё не закончился, то данное значение равно 0, его можно отдельно посчитать, поделив powerScore на countMeasures),
	"powerScore": суммарное потребление со всех измерений за текущий день,
	"time": "timestamp в формате %d.%m.%Y"
}
Для type == month:
{
	"countMeasures": количество измерений,
	"days": массив данных по дням в формате для type == day,
	"power": среднее значение потребления за текущий месяц (если месяц ещё не закончился, то данное значение равно 0, его можно отдельно посчитать, поделив powerScore на countMeasures),
	"powerScore": суммарное потребление со всех измерений за текущий месяц,
	"time": "timestamp в формате %m.%Y"
}
